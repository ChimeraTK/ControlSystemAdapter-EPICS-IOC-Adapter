#!/usr/bin/python3
## Script to convert ChimeraTK process variable summeries in xml format to EPICS .db files
## Written and tested for Python 3.5.2 @ July 2018 by Patrick Nonn for DESY/MSK

import xml.etree.ElementTree as ET # xml parser
import re # For regular expressions
import sys
import os # For file manipulation
import argparse # Parse command line arguments

VERSION = '1.0'

# changelog:
# 1.0: First working version

def makeIndex(xmlNode, nsPrefix, nsDict, pvPath = ''):
    '''
    Recursive function to iterate through the xml tree and isolate the 'variables' while maintaining the path in order to generate an index.
    Takes:
        xmlNode: xml handle to start the recursion
        nsPrefix: Namespace prefix (without ':')
        nsDict: Namespace dictionary, containing nsPrefix
        pvPath: Path to the node, from which the function is called.
    Returns:
        index: dictionary, holding PV and handle for the corresponding 'variable'-node
    '''
    index = {}
    for v in xmlNode.findall(nsPrefix + ':variable', nsDict):
        index[pvPath + v.get('name')] = v
    for d in xmlNode.findall(nsPrefix + ':directory', nsDict):
        index.update(makeIndex(d, nsPrefix, nsDict, pvPath = pvPath + d.get('name') + '/'))
    return index

def extractIndex(index, regex):
    '''
    Sort all PVs, which contain a substring matching regex, into indexOut and the remaining PVs into indexResidue.
    Takes:
        index: index containing a dictionary of PV, xml handle pairs, as generated by "makeIndex()"
        regex: regular expression
    Returns:
        indexOut: index containing matching entries
        indexResidue: index containing remaining entries
    '''
    pattern = re.compile(regex)
    indexOut = {}
    indexResidue = {}
    for pv in index.keys():
        if pattern.match(pv) == None:
            indexResidue[pv] = index[pv]
        else:
            indexOut[pv] = index[pv]
    return indexOut, indexResidue

def readVar(index, nsPrefix, nsDict):
    '''
    Generates list of dictionaries, holding information to generate .db records.
    Takes:
        index: Index holding the pv's to read.
        nsPrefix: Namespace prefix (without ':')
        nsDict: Namespace dictionary, containing nsPrefix
    Returns:
        listVar: List of dictionaries, holding the variable information
    '''
    listVar = []
    for pv in sorted(index.keys()):
        listVar.append(genDbEntry(pv, index[pv], nsPrefix, nsDict))
    return listVar

def genDbEntry(pv, xmlHandle, nsPrefix, nsDict):
    '''
    Function to extract data from a 'variable' entry in a ChimeraTK xml file and returns it as dictionary.
    Takes:
        pv: full EPICS process variable
        xmlHandle: Handle of the 'variable' entry
        nsPrefix: Namespace prefix (without ':')
        nsDict: Namespace dictionary, containing nsPrefix
    Returns:
        dbEntry: A dictionary, containing all the information needed to buils epics db entrys
    '''
    dbEntry={}
    # Dictionary to convert standard data types into EPICS equivalents.
    typeConversion = dict([('int32', 'LONG'), ('uint32', 'ULONG'), ('int16', 'SHORT'), ('uint16', 'USHORT'), ('int8', 'CHAR'), ('uint8', 'UCHAR'), ('double', 'DOUBLE'), ('float', 'FLOAT'), ('string', 'STRING')])
    # Generating entries for db record with exeption handling, if necessary (i.e. description).
    dbEntry['PV'] = pv
    dbEntry['DTYP'] = 'ChimeraTK' # FIXME: Is generic, might be extracted from .dbd?
    
    description = xmlHandle.find(nsPrefix + ':description', nsDict).text
    if description == None:
        dbEntry['DESC'] = ''
    else:
        dbEntry['DESC'] = description[0:28]
    
    engineerunit = xmlHandle.find(nsPrefix + ':unit', nsDict).text
    if engineerunit == None:
        dbEntry['EGU'] = ''
    else:
        dbEntry['EGU'] = engineerunit
    
    dbEntry['SCAN'] = '1 second' # FIXME: Is generic. 
    dbEntry['FTVL'] = typeConversion[xmlHandle.find(nsPrefix + ':value_type', nsDict).text]
    dbEntry['dirLink'] = '@$(APP) ' + dbEntry['PV']
    dbEntry['numElements'] = int(xmlHandle.find(nsPrefix + ':numberOfElements', nsDict).text)
    
    if  xmlHandle.find(nsPrefix + ':direction', nsDict).text == 'application_to_control_system':
        dbEntry['dir'] = 'INP'
        if dbEntry['numElements'] == 1:
            if dbEntry['FTVL'] in ['LONG', 'ULONG', 'SHORT', 'USHORT', 'CHAR', 'UCHAR']:
                dbEntry['recordType'] = 'longin'
            elif dbEntry['FTVL'] in ['DOUBLE', 'FLOAT']:
                dbEntry['recordType'] = 'ai'
            elif dbEntry['FTVL'] in ['STRING']:
                dbEntry['recordType'] = 'stringin'
        elif dbEntry['numElements'] > 1:
            dbEntry['recordType'] = 'aai'
            dbEntry['NELM'] = str(dbEntry['numElements'])
    elif xmlHandle.find(nsPrefix + ':direction', nsDict).text == 'control_system_to_application':
        dbEntry['dir'] = 'OUT'
        if dbEntry['numElements'] == 1:
            if dbEntry['FTVL'] in ['LONG', 'ULONG', 'SHORT', 'USHORT', 'CHAR', 'UCHAR']:
                dbEntry['recordType'] = 'longout'
            elif dbEntry['FTVL'] in ['DOUBLE', 'FLOAT']:
                dbEntry['recordType'] = 'ao'
            elif dbEntry['FTVL'] in ['STRING']:
                dbEntry['recordType'] = 'stringout'
        elif dbEntry['numElements'] > 1:
            dbEntry['recordType'] = 'aao'
            dbEntry['NELM'] = str(dbEntry['numElements'])    
    
    return dbEntry

def writeDB(dbfile, records, maxLengthPV, ind='  '):
    # Open file
    with open(dbfile, 'w') as fh:
        # Write head of db file
        fh.write('# File automatically generated by xml2db.\n# Please backup file, before manually changing it.\n\n')
        for e in records:
            PVname = shortenPV(e['PV'], maxLengthPV)
            if e['numElements'] == 1:
                if e['FTVL'] in ['STRING', 'CHAR']: # FIXME: String PVs are generated but commented, as there is an unknown problem, yet.
                    indTemp = ind
                    ind = '#'
                    fh.write('#record(' + e['recordType'] + ', \"$(P)$(R)' + PVname + '\"){\n' + ind + 'field(DTYP, \"' + e['DTYP'] + '\")\n' + ind + 'field(DESC, \"' + e['DESC'] + '\")\n' + ind + 'field(' + e['dir'] + ', \"' + e['dirLink'] + '\")\n' + ind + 'field(SCAN, \"' + e['SCAN'] + '\")\n#}\n\n')
                    ind = indTemp
                else:
                    fh.write('record(' + e['recordType'] + ', \"$(P)$(R)' + PVname + '\"){\n' + ind + 'field(DTYP, \"' + e['DTYP'] + '\")\n' + ind + 'field(DESC, \"' + e['DESC'] + '\")\n' + ind + 'field(' + e['dir'] + ', \"' + e['dirLink'] + '\")\n' + ind + 'field(SCAN, \"' + e['SCAN'] + '\")\n' + ind + 'field(EGU, \"' + e['EGU'] + '\")\n}\n\n')
            elif e['numElements'] > 1:
                fh.write('record(' + e['recordType'] + ', \"$(P)$(R)' + PVname + '\"){\n' + ind + 'field(DTYP, \"' + e['DTYP'] + '\")\n' + ind + 'field(DESC, \"' + e['DESC'] + '\")\n' + ind + 'field(' + e['dir'] + ', \"' + e['dirLink'] + '\")\n' + ind + 'field(SCAN, \"' + e['SCAN'] + '\")\n' + ind + 'field(EGU, \"' + e['EGU'] + '\")\n' + ind + 'field(FTVL, \"' + e['FTVL'] + '\")\n' + ind + 'field(NELM, \"' + e['NELM'] + '\")\n}\n\n')

def writeReq(reqfile, records, maxLengthPV, macro):
    # Open file
    with open(reqfile, 'w') as fh:
        for e in records:
            PVname = macro + shortenPV(e['PV'], maxLengthPV)
            if e['FTVL'] in ['STRING', 'CHAR']:
                fh.write('#' + PVname + '\n')
            else:
                fh.write(PVname + '\n')

def shortenPV(inPV, maxLength, sep='/'):
    '''
    Attempts to meaningful shorten the PV name by abbreviating.
    Takes:
        inPV: String to shorten
        sep: Seperators used in inPV
    Returns:
        newPV: shortened PV
    '''
    # Testing if inPV is too long in the first place
    if len(inPV) <= maxLength:
        return inPV
    # Defining dictionary with abbreviations
    abbr = dict([('amplitude', 'amp'), ('Amplitude', 'Amp'), ('phase', 'ph'), ('Phase', 'Ph'), ('calibration', 'cal'), ('Calibration', 'Cal'), ('after', 'aft'), ('After', 'Aft'), ('average', 'avg'), ('Average', 'Avg'), ('request', 'req'), ('Request', 'Req'), ('deviation', 'dev'), ('Deviation', 'Dev'), ('standard', 'std'), ('Standard', 'Std'), ('register', 'reg'), ('Register', 'Reg'), ('registers', 'regs'), ('Registers', 'Regs'), ('maximum', 'max'), ('Maximum', 'Max'), ('minimum', 'min'), ('Minimum', 'Min')])
    # Calculating overlength and seperating into parts defined by separators
    over = len(inPV)-maxLength
    if CLA.verbose:
        print(inPV + ' is ' + str(over) + ' Characters too long:')
    names = inPV.split(sep)
    names.reverse() # to start with the last part of the PV
    newNames = []
    # Searching for replaceable words
    for name in names:
        if over <= 0:
            newNames.append(name)
        else:
            words=re.findall('[a-zA-Z][^A-Z]*', name) # splits wordtrains at uppercase letters: wordTrainToNowhere -> word Train To Nowhere
            newWords = ''
            for word in words:            
                if over <= 0: # If PV is short enough
                    newWords += word
                else:
                    if word in list(abbr.keys()):
                        newWord = abbr[word]
                        newWords += newWord
                        over -= len(word) - len(newWord)
                    else:
                        newWords += word
            newNames.append(newWords)
    # In case a reasonable abbreviation was not enough, just cut the sucker down
    if over > 0:
        cutName = newNames[0][:-over]
        if cutName == None:
            sys.exit('Error: PV ' + inPV + ' too long and couldn\'t be shortened.')
        newNames[0] = cutName
    # Construction of new PV
    newPV = ''
    newNames.reverse()
    
    for i in range(len(newNames)-1):
        newPV += newNames[i] + '/'
    
    newPV += newNames[len(newNames)-1]
    if CLA.verbose:
        print('Exchange\n\t' + inPV + '\nwith\n\t' + newPV + '\n')
    return newPV

# initialize Command Line Argument Parser
CLAP=argparse.ArgumentParser(description='Writes EPICS record for every \'variable\' defined in ChimeraTK-xml file to EPICS database file. Optionally a subset of PVs, described by a regular expression, can be extracted and autosave request files can be created additionally or exclusively.') 
# Set up command line arguments
CLAP.add_argument('path_xml', help='Path of ChimeraTK xml file')
CLAP.add_argument('path_db', help='Path of EPICS db file')
CLAP.add_argument('-x', '--extract', help='Generates .db file, which only contains records for PVs matching the regular expression EXTRACT')
REQ = CLAP.add_mutually_exclusive_group()
REQ.add_argument('-r', '--asRequest', help='Generate additionally an autosave request file as <path_db>.req with MACRO being the entirety of macros used, when loading the records.', metavar='MACRO', nargs='?', const='')
REQ.add_argument('-o', '--asRequestOnly', help='Generate just an autosave request file as <path_db>.req with MACRO being the entirety of macros used, when loading the records.', metavar='MACRO', nargs='?', const='')
CLAP.add_argument('-m', '--macro', help='Maximum combined length of macros used, when loading the records. Is subtracted from max length of PVs. Defaults to 5.', type=int, default=5, metavar='length_of_macros')
CLAP.add_argument('-v', '--verbose', help='Activates verbosity', action='store_true')
CLAP.add_argument('-ver', '--version', help='Prints version and exits', action='version', version=VERSION)
CLAP.add_argument('-ns', '--namespace', help='Define a different xml namespace. Default: https://github.com/ChimeraTK/ApplicationCore')
# Parse Command Line Arguments
CLA=CLAP.parse_args()

# Process xml namespace argument.
if CLA.namespace==None:
    ns = {'AppCore': 'https://github.com/ChimeraTK/ApplicationCore'}
else:
    ns = {'AppCore': CLA.namespace}

# Process path_db argument.
dbfilePath, dbfileName = os.path.split(os.path.abspath(CLA.path_db))
if not os.path.isdir(dbfilePath):
    sys.exit('Error: Path to db file does not exist.')
elif dbfileName == '':
    sys.exit('Error: Please add filename.')
else:
    indDot = dbfileName.rfind('.')
    if indDot in [-1, 0]:
        reqfileName = dbfilename + '.req'
    else:
        reqfileName = dbfileName[:indDot] + '.req'
    reqfile = os.path.join(dbfilePath, reqfileName)
    dbfile = os.path.join(dbfilePath, dbfileName)

# Process asRequest and asRequestOnly argument
if CLA.asRequest != None:
    asMacro = CLA.asRequest
elif CLA.asRequestOnly != None:
    asMacro = CLA.asRequestOnly
else:
    asMacro = None

# Process macro argument
maxPVLen = 60 - CLA.macro

# Parse xml file.
tree = ET.parse(CLA.path_xml)
root = tree.getroot()
# Generate Index
if CLA.verbose:
    print('Generating Index')
index = makeIndex(root, 'AppCore', ns)
# Extract index subset, if needed
if CLA.extract != None:
    if CLA.verbose:
        print('Extract PVs with ' + CLA.extract + 'from index')
    newIndex, resIndex = extractIndex(index, CLA.extract)
    resdbfile = dbfile[:-3] + '_res' + dbfile[-3:]
    # Read "variables" of given index.
    variablesRes = readVar(resIndex, 'AppCore', ns)
    if CLA.verbose:
        print('Write File: ' + resdbfile)
    # Write _res.db file
    if CLA.asRequestOnly != None:
        writeDB(resdbfile, variablesRes, maxPVLen)
else:
    newIndex = index
    
# Read "variables" of given index.
variables = readVar(newIndex, 'AppCore', ns)
# Write autosave request file
if asMacro != None:
    if CLA.verbose:
        print('Write File ' + reqfile)
    writeReq(reqfile, variables, maxPVLen, asMacro)
if CLA.verbose:
    print('Write File: ' + dbfile)
# Write .db file
if not CLA.asRequestOnly != None:
    writeDB(dbfile, variables, maxPVLen)