#!/usr/bin/python3
## Script to convert ChimeraTK process variable summeries in xml format to EPICS .db files
## Written and tested for Python 3.5.2 @ July 2018 by Patrick Nonn for DESY/MSK

import xml.etree.ElementTree as ET # xml parser
import re # For regular expressions
import sys
import os # For file manipulation
import argparse # Parse command line arguments

VERSION = '1.2'

# changelog:
# 1.0: First working version
# 1.1: Added replacement of periods in PV names
# 1.1: Added exception handling for unexpected entries in xml file
# 1.2: Added feature: Generation of "documentation" file

def makeIndex(xmlNode, nsPrefix, nsDict, pvPath = ''):
    '''
    Recursive function to iterate through the xml tree and isolate the 'variables' while maintaining the path in order to generate an index.
    Takes:
        xmlNode: xml handle to start the recursion
        nsPrefix: Namespace prefix (without ':')
        nsDict: Namespace dictionary, containing nsPrefix
        pvPath: Path to the node, from which the function is called.
    Returns:
        index: dictionary, holding PV and handle for the corresponding 'variable'-node
    '''
    index = {}
    for v in xmlNode.findall(nsPrefix + ':variable', nsDict):
        index[pvPath + v.get('name')] = v
    for d in xmlNode.findall(nsPrefix + ':directory', nsDict):
        index.update(makeIndex(d, nsPrefix, nsDict, pvPath = pvPath + d.get('name') + '/'))
    return index

def extractIndex(index, regex):
    '''
    Sort all PVs, which contain a substring matching regex, into indexOut and the remaining PVs into indexResidue.
    Takes:
        index: index containing a dictionary of PV, xml handle pairs, as generated by "makeIndex()"
        regex: regular expression
    Returns:
        indexOut: index containing matching entries
        indexResidue: index containing remaining entries
    '''
    pattern = re.compile(regex)
    indexOut = {}
    indexResidue = {}
    for pv in index.keys():
        if pattern.match(pv) == None:
            indexResidue[pv] = index[pv]
        else:
            indexOut[pv] = index[pv]
    return indexOut, indexResidue

def readVar(index, nsPrefix, nsDict, repDot):
    '''
    Generates list of dictionaries, holding information to generate .db records.
    Takes:
        index: Index holding the pv's to read.
        nsPrefix: Namespace prefix (without ':')
        nsDict: Namespace dictionary, containing nsPrefix
    Returns:
        listVar: List of dictionaries, holding the variable information
    '''
    listVar = []
    for pv in sorted(index.keys()):
        tempDBEntry = genDbEntry(pv, index[pv], nsPrefix, nsDict, repDot)
        if tempDBEntry != None: # Check for invalid entries
            listVar.append(tempDBEntry)
    return listVar

def genDbEntry(pv, xmlHandle, nsPrefix, nsDict, repDot):
    '''
    Function to extract data from a 'variable' entry in a ChimeraTK xml file and returns it as dictionary.
    Takes:
        pv: full EPICS process variable
        xmlHandle: Handle of the 'variable' entry
        nsPrefix: Namespace prefix (without ':')
        nsDict: Namespace dictionary, containing nsPrefix
        repDot: Replacement for periods
    Returns:
        dbEntry: A dictionary, containing all the information needed to buils epics db entrys
    '''
    dbEntry={}
    # Dictionary to convert standard data types into EPICS equivalents.
    typeConversion = dict([('int32', 'LONG'), ('uint32', 'ULONG'), ('int16', 'SHORT'), ('uint16', 'USHORT'), ('int8', 'CHAR'), ('uint8', 'UCHAR'), ('double', 'DOUBLE'), ('float', 'FLOAT'), ('string', 'STRING')])
    # Generating entries for db record with exeption handling, if necessary (i.e. description).
    dbEntry['PV'] = re.sub('\.',repDot,pv) # Replaces all periods (.) with underscores (_), to avoid invalid PV names.
    dbEntry['DTYP'] = 'ChimeraTK' # FIXME: Is generic, might be extracted from .dbd?
    
    try:
        description = xmlHandle.find(nsPrefix + ':description', nsDict).text
    except AttributeError:
        sys.stderr.write('Variable \"' + pv + '\" seems to have no <description> field.\n\tRecord <' + dbEntry['PV'] + '> will have empty DESC field.\n\n')
        description = None
    
    if description == None:
        dbEntry['DESC'] = ''
    else:
        dbEntry['DESC'] = str(description)
    
    try:
        engineerunit = xmlHandle.find(nsPrefix + ':unit', nsDict).text
    except AttributeError:
        sys.stderr.write('Variable \"' + pv + '\" seems to have no <unit> field.\n\tRecord <' + dbEntry['PV'] + '> will have empty EGU field.\n\n')
        engineerunit = None
    
    if engineerunit == None:
        dbEntry['EGU'] = ''
    else:
        dbEntry['EGU'] = engineerunit
    
    dbEntry['SCAN'] = '.1 second' # FIXME: Is generic. 
    try:
        dbEntry['FTVL'] = typeConversion[xmlHandle.find(nsPrefix + ':value_type', nsDict).text]
    except KeyError:
        sys.stderr.write('\"' + xmlHandle.find(nsPrefix + ':value_type', nsDict).text + '\" is not a recognized variable type.\n\tRecord <' + dbEntry['PV'] + '> will be omitted.\n\n')
        return None
    except AttributeError:
        sys.stderr.write('Variable \"' + pv + '\" seems to have no <value_type> field.\n\tRecord <' + dbEntry['PV'] + '> will be omitted.\n\n')
        return None

    dbEntry['dirLink'] = '@$(APP) ' + pv
    try:
        dbEntry['numElements'] = int(xmlHandle.find(nsPrefix + ':numberOfElements', nsDict).text)
    except AttributeError:
        sys.stderr.write('Variable \"' + pv + '\" seems to have no <numberOfElements> field.\n\tRecord <' + dbEntry['PV'] + '> will be omitted.\n\n')
        return None
    
    try:
        Direction = xmlHandle.find(nsPrefix + ':direction', nsDict).text
    except AttributeError:
        sys.stderr.write('Variable \"' + pv + '\" seems to have no <direction> field.\n\tRecord <' + dbEntry['PV'] + '> will be omitted.\n\n')
        return None
    
    if  Direction == 'application_to_control_system':
        dbEntry['dir'] = 'INP'
        if dbEntry['numElements'] == 1:
            if dbEntry['FTVL'] in ['LONG', 'ULONG', 'SHORT', 'USHORT', 'CHAR', 'UCHAR']:
                dbEntry['recordType'] = 'longin'
            elif dbEntry['FTVL'] in ['DOUBLE', 'FLOAT']:
                dbEntry['recordType'] = 'ai'
            elif dbEntry['FTVL'] in ['STRING']:
                dbEntry['recordType'] = 'stringin'
            else:
                sys.stderr.write('\"' + dbEntry['recordType'] + '\" is not recognized.\n\tRecord <' + dbEntry['PV'] + '> will be omitted.\n\n')
                return None
        elif dbEntry['numElements'] > 1:
            if dbEntry['FTVL'] in ['LONG', 'ULONG', 'SHORT', 'USHORT', 'CHAR', 'UCHAR', 'DOUBLE', 'FLOAT', 'STRING']:
                dbEntry['recordType'] = 'aai'
                dbEntry['NELM'] = str(dbEntry['numElements'])
            else:
                sys.stderr.write('\"' + dbEntry['recordType'] + '\" is not recognized.\n\tRecord <' + dbEntry['PV'] + '> will be omitted.\n\n')
                return None
    elif Direction == 'control_system_to_application':
        dbEntry['dir'] = 'OUT'
        if dbEntry['numElements'] == 1:
            if dbEntry['FTVL'] in ['LONG', 'ULONG', 'SHORT', 'USHORT', 'CHAR', 'UCHAR']:
                dbEntry['recordType'] = 'longout'
            elif dbEntry['FTVL'] in ['DOUBLE', 'FLOAT']:
                dbEntry['recordType'] = 'ao'
            elif dbEntry['FTVL'] in ['STRING']:
                dbEntry['recordType'] = 'stringout'
            else:
                sys.stderr.write('\"' + dbEntry['recordType'] + '\" is not recognized.\n\tRecord <' + dbEntry['PV'] + '> will be omitted.\n\n')
                return None
        elif dbEntry['numElements'] > 1:
            if dbEntry['FTVL'] in ['LONG', 'ULONG', 'SHORT', 'USHORT', 'CHAR', 'UCHAR', 'DOUBLE', 'FLOAT', 'STRING']:
                dbEntry['recordType'] = 'aao'
                dbEntry['NELM'] = str(dbEntry['numElements'])
            else:
                sys.stderr.write('\"' + dbEntry['recordType'] + '\" is not recognized.\n\tRecord <' + dbEntry['PV'] + '> will be omitted.\n\n')
                return None
    else:
        sys.stderr.write('\"' + Direction + '\" is not a recognized entry for <direction>.\n\tRecord <' + dbEntry['PV'] + '> will be omitted.\n\n')
        return None
    
    return dbEntry

def writeDB(dbfile, records, maxLengthPV, ind='  '):
    # Open file
    with open(dbfile, 'w') as fh:
        # Write head of db file
        fh.write('# File automatically generated by xml2db.\n# Please backup file, before manually changing it.\n\n')
        # Compose and write records
        for e in records:
            PVname = shortenPV(e['PV'], maxLengthPV)
            if e['numElements'] == 1:
                if e['FTVL'] in ['STRING', 'CHAR']:
                    indTemp = ind
                    ind = '#'
                    fh.write('#record(' + e['recordType'] + ', \"' + MacroString + PVname + '\"){\n' + ind + 'field(DTYP, \"' + e['DTYP'] + '\")\n' + ind + 'field(' + e['dir'] + ', \"' + e['dirLink'] + '\")\n' + ind + 'field(SCAN, \"' + e['SCAN'] + '\")\n#}\n\n')
                    ind = indTemp
                else:
                    fh.write('record(' + e['recordType'] + ', \"' + MacroString + PVname + '\"){\n' + ind + 'field(DTYP, \"' + e['DTYP'] + '\")\n' + ind + 'field(' + e['dir'] + ', \"' + e['dirLink'] + '\")\n' + ind + 'field(SCAN, \"' + e['SCAN'] + '\")\n' + ind + 'field(EGU, \"' + e['EGU'] + '\")\n}\n\n')
            elif e['numElements'] > 1:
                fh.write('record(' + e['recordType'] + ', \"' + MacroString + PVname + '\"){\n' + ind + 'field(DTYP, \"' + e['DTYP'] + '\")\n' + ind + 'field(' + e['dir'] + ', \"' + e['dirLink'] + '\")\n' + ind + 'field(SCAN, \"' + e['SCAN'] + '\")\n' + ind + 'field(EGU, \"' + e['EGU'] + '\")\n' + ind + 'field(FTVL, \"' + e['FTVL'] + '\")\n' + ind + 'field(NELM, \"' + e['NELM'] + '\")\n}\n\n')

def writeReq(reqfile, records, maxLengthPV, macro):
    # Open file
    with open(reqfile, 'w') as fh:
        for e in records:
            PVname = macro + shortenPV(e['PV'], maxLengthPV)
            if e['FTVL'] in ['STRING', 'CHAR']:
                fh.write('#' + PVname + '\n')
            elif e['dir'] == 'OUT':
                fh.write(PVname + '\n')

def writeDoc(docfile, dbfile, xmlfile, records, maxLengthPV, macro):
    # Open file
    with open(docfile, 'w') as fh:
        #write Head
        fh.write('This file contains a list of all PVs, contained in\n' + dbfile + '\naccompanied by the description as delivered in\n' + xmlfile + '\n\n')
        #write list of PV with descriptions
        for e in records:
            PVname = macro + shortenPV(e['PV'], maxLengthPV)
            fh.write(PVname + ':\n\t' + e['DESC'] + '\n\n')


def shortenPV(inPV, maxLength, sep='/', justCheck=False):
    '''
    Attempts to meaningful shorten the PV name by abbreviating.
    Takes:
        inPV: String to shorten
        sep: Seperators used in inPV
    Returns:
        newPV: shortened PV
    '''
    global WriteFlag
    over = len(inPV)-maxLength
    if CLA.shorter == None and over > 0:
        sys.stderr.write('Error: ' + inPV + ' is ' + str(over) + ' Characters too long!\n\n')
        WriteFlag = False
        return
    elif justCheck:
        return
    elif CLA.shorter == None:
        return inPV

    # Testing if inPV is too long in the first place
    if len(inPV) <= maxLength and CLA.shorter != 3:
        return inPV

    # Loading dictionary with abbreviations from file dictionary.py.
    from dictionary import abbreviation
    abbr = abbreviation()

    # Calculating overlength and seperating into parts defined by separators
    if CLA.verbose:
        print(inPV + ' is ' + str(over) + ' Characters too long:')
    if CLA.shorter >= 2:
        names = inPV.split(sep)
        names.reverse() # to start with the last part of the PV
        newNames = []
    elif CLA.shorter == 1:
        p1, p2, Name = inPV.rpartition(sep)
        names = [ Name ]
        pathpv = p1 + p2
        newNames = ''

    # Searching for replaceable words
    for name in names:
        if over <= 0 and CLA.shorter != 3: # If PV is short enough (and -sss is not set) bypass shortening
            if CLA.shorter == 2:
                newNames.append(name)
            elif CLA.shorter == 1:
                newNames += name
        else:
            words=re.findall('[a-zA-Z][^A-Z]*', name) # splits wordtrains at uppercase letters: wordTrainToNowhere -> word Train To Nowhere
            newWords = ''
            for word in words:            
                if over <= 0 and CLA.shorter != 3: # If PV is short enough (and -sss is not set) bypass shortening
                    newWords += word
                else:
                    if word in list(abbr.keys()):
                        if CLA.verbose:
                            print('Word ' + word + ' found.' )
                        newWord = abbr[word]
                        newWords += newWord
                        over -= len(word) - len(newWord)
                    else:
                        newWords += word
            if CLA.shorter >= 2:
                newNames.append(newWords)
            elif CLA.shorter == 1:
                newNames += newWords

    # In case a reasonable abbreviation was not enough, just cut the sucker down
    if over > 0:
        if CLA.shorter >= 2:
            cutName = newNames[0][:-over]
        elif CLA.shorter == 1:
            cutName = newNames[:-over]
        if cutName == None:
            sys.stderr.write('Error: PV ' + inPV + ' too long and couldn\'t be shortened.\n\n')
            WriteFlag = False
        if CLA.shorter >= 2:
            newNames[0] = cutName
        elif CLA.shorter == 1:
            newNames = cutName

    # Construction of new PV
    newPV = ''
    if CLA.shorter >= 2:
        newNames.reverse()
        for i in range(len(newNames)-1):
            newPV += newNames[i] + '/'
        newPV += newNames[len(newNames)-1]
    elif CLA.shorter == 1:
        newPV = pathpv + newNames
    
    if CLA.verbose:
        print('Exchange\n\t' + inPV + '\nwith\n\t' + newPV + '\n')
    return newPV

# initialize Command Line Argument Parser
CLAP=argparse.ArgumentParser(description='Writes EPICS record for every \'variable\' defined in ChimeraTK-xml file to EPICS database file. Optionally a subset of PVs, described by a regular expression, can be extracted and autosave request files can be created additionally or exclusively.') 
# Set up command line arguments
CLAP.add_argument('path_xml', help='Path of ChimeraTK xml file')
CLAP.add_argument('path_db', help='Path of EPICS db file')
CLAP.add_argument('-x', '--extract', help='Generates .db file, which only contains records for PVs matching the regular expression RegEx', metavar='RegEx')
REQ = CLAP.add_mutually_exclusive_group()
REQ.add_argument('-r', '--asRequest', help='Generate additionally an autosave request file as <path_db>.req with MACRO being the entirety of macros used, when loading the records.', action='store_true')
REQ.add_argument('-ro', '--asRequestOnly', help='Generate just an autosave request file as <path_db>.req with MACRO being the entirety of macros used, when loading the records.', action='store_true')
DOC = CLAP.add_mutually_exclusive_group()
DOC.add_argument('-d', '--Documentation', help='Generates file with PVnames + description from xml file.', action='store_true')
DOC.add_argument('-do', '--DocumentationOnly', help='Generates only file with PVnames + description from xml file.', action='store_true')
CLAP.add_argument('-m', '--macro', help='Maximum combined length of macros used, when loading the records. Is subtracted from max length of PVs. Defaults to 5.', type=int, default=5, metavar='length_of_macros')
CLAP.add_argument('-M', '--Macro', help='Macros used, when loading the records, i.e. $(P). Will be added at the beginning of the PV name. Also used for .req and documentation files. Defaults to empty string', default='', metavar='macro_string')
CLAP.add_argument('-v', '--verbose', help='Activates verbosity', action='store_true')
CLAP.add_argument('-ver', '--version', help='Prints version and exits', action='version', version=VERSION)
CLAP.add_argument('-s', '--shorter', help='-s shortens just the last part of th PV. -ss shortens also parts of the PV before the last separator. -sss shortens every part of every PV indiscriminately', action='count')
CLAP.add_argument('-D', '--pathToDict', help='Path to the file "dictionary.py". Only necessary, if it is not in this directory, nor a directory defined in the environment variable "PYTHONPATH".', metavar='path')
CLAP.add_argument('-ns', '--namespace', help='Define a different xml namespace. Default: https://github.com/ChimeraTK/ApplicationCore', metavar='xml_NameSpace')
CLAP.add_argument('-R', '--replacePeriod', help='Character(s) with which to replace period <.> in PV names. Has to be valid for PV names.', default='-', metavar='char')
# Parse Command Line Arguments
CLA=CLAP.parse_args()

# Process xml namespace argument.
if CLA.namespace==None:
    ns = {'AppCore': 'https://github.com/ChimeraTK/ApplicationCore'}
else:
    ns = {'AppCore': CLA.namespace}

# Process path_db argument.
dbfilePath, dbfileName = os.path.split(os.path.abspath(CLA.path_db))
if not os.path.isdir(dbfilePath):
    sys.exit('Error: Path to db file does not exist.')
elif dbfileName == '':
    sys.exit('Error: Please add filename.')
else:
    indDot = dbfileName.rfind('.')
    if indDot in [-1, 0]:
        reqfileName = dbfileName + '.req'
    else:
        reqfileName = dbfileName[:indDot] + '.req'
    
    if indDot in [-1, 0]:
        docfileName = dbfileName + '_doc.txt'
    else:
        docfileName = dbfileName[:indDot] + '_doc.txt'
    
    reqfile = os.path.join(dbfilePath, reqfileName)
    dbfile = os.path.join(dbfilePath, dbfileName)
    docfile = os.path.join(dbfilePath, docfileName)

# Process macro argument
maxPVLen = 60 - CLA.macro

# Process Macro argument
if CLA.Macro != None:
    MacroString = CLA.Macro

# Process pathToDict argument
if CLA.pathToDict != None:
    if not os.path.isdir(CLA.pathToDict):
        sys.stderr.write('Error: The directory given to -D / --pathToDict does not exist! \n\t-s / --shorter flag(s) will be ignored\n\n')
        CLA.shorter = None
    else:
        sys.path.append(os.path.realpath(CLA.pathToDict))

# Process shorter argument
if CLA.shorter != None and  CLA.shorter > 3:
    sys.exit('Error: Too much -s! Maximum three are allowed')

# Process replacePeriod argument
if any(elem in CLA.replacePeriod for elem in '.$()$#\"\'\\'):
    sys.stderr.write('Error: The character \"' + CLA.replacePeriod + '\" is invalid in PV names.\n\tDefault (_) will be used, instead.\n\n')
    repDot = '_'
else:
    repDot = CLA.replacePeriod
    
# Parse xml file.
tree = ET.parse(CLA.path_xml)
root = tree.getroot()

# Generate Index
if CLA.verbose:
    print('Generating Index')
index = makeIndex(root, 'AppCore', ns)

# Extract index subset, if needed
WriteFlag = True
if CLA.extract != None:
    if CLA.verbose:
        print('Extract PVs with ' + CLA.extract + 'from index')
    newIndex, resIndex = extractIndex(index, CLA.extract)
    resdbfile = dbfile[:-3] + '_res' + dbfile[-3:]
    # Read "variables" of given index.
    variablesRes = readVar(resIndex, 'AppCore', ns, repDot)
    # Check for long PV names
    if CLA.shorter == None:
        for i in variablesRes:
            shortenPV(i['PV'], maxPVLen, justCheck=True)
    if CLA.verbose:
        print('Write File: ' + resdbfile)
    # Write _res.db file
    if not CLA.asRequestOnly and WriteFlag:
        writeDB(resdbfile, variablesRes, maxPVLen)
    elif not WriteFlag:
        sys.stderr.write('Error: ' + str(resdbfile) + ' was not written, due to overlong PVs\n')
else:
    newIndex = index
    
# Read "variables" of given index.
variables = readVar(newIndex, 'AppCore', ns, repDot)

WriteFlag = True
# Check for too long PVs, if necessary
if CLA.shorter == None:
    for i in variables:
        shortenPV(i['PV'], maxPVLen, justCheck=True)
if not WriteFlag:
    sys.exit('Error: Too long PV(s), ' + str(dbfile) + ' was not written!\n')
    
# Write autosave request file
if CLA.asRequest or CLA.asRequestOnly:
    if CLA.verbose:
        print('Write File ' + reqfile)
    writeReq(reqfile, variables, maxPVLen, MacroString)

# Write .db file
if CLA.verbose:
    print('Write File: ' + dbfile)
if not CLA.asRequestOnly or not CLA.DocumentationOnly:
    writeDB(dbfile, variables, maxPVLen)

#Write Documentation
if CLA.Documentation or CLA.DocumentationOnly:
    if CLA.verbose:
        print('Write File: ' + docfile)
    writeDoc(docfile, dbfile, CLA.path_xml, variables, maxPVLen, MacroString)