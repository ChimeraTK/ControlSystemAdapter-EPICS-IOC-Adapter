#!/usr/bin/python3
## Tool to generate EPICS PV database, autosave requirement file and documentation for PV database from a configuration xml-file and various sources
## Written and tested for Python 3.5.2 @ June 2019 by Patrick Nonn for DESY/MSK

import xml.etree.ElementTree as ET # xml parser
import re # For regular expressions
import sys
import os # For file manipulation
import argparse # Parse command line arguments
import numpy as np

VERSION = '0.1'

'''
Changelog:

Unreleased:
    Parsing of xml-files and extracting information for mapping
'''

## Class to build structs
class struct:
    pass

## Class for text formatting
class asciiformat:
    bold = lambda text: '\033[1m' + text + '\033[0m'
    warning = '\033[1m\033[93mWarning:\033[0m '
    error = '\033[1m\033[91mError:\033[0m '

## Define Exception
class XmlNodeError(Exception):
    """Exception raised, if xml-node invalid"""
    
    def __init__(self, xPath, message):
        self.xPath = xPath
        self.message = message

## Specialized container class to hold and query structured data
class table:
    ## Constructor
    def __init__(self, columnNames, contentList=None):
        if not isinstance(columnNames, (list,str)): # Check for right attribute type
            raise TypeError('The first attribute of table() has to be of type list or string!')
        if isinstance(columnNames, str): # Conversion to list type if it is string
            columnNames = [columnNames]
        elif not all(map(lambda x: isinstance(x, str), columnNames)): # Check for list content being string
            raise TypeError('The first attribute of table() has to be a list of strings!')
        elif len(columnNames) != len(set(columnNames)): # Check for duplicates
            raise AttributeError('The first attribute of table() can\'t contain duplicates!') 
        else:
            self._head = columnNames
        if contentList != None: # Process content given at initialization
            if not all(map(lambda x: isinstance(x, (list,dict)), contentList)): # Check types
                raise TypeError('The second attribute of table() has to be None or a list of lists or dictionaries!')
            if any(map(lambda x: len(x)<len(columnNames), contentList)): # Check lengths of items
                raise AttributeError('The second attribute of table() has to be a list of lists or dictionaries, which are of the same length, as the first attribute!')
            if all(map(lambda x: isinstance(x, dict), contentList)): # Process list of dictionaries
                if any(map(lambda item: any(map(lambda col: all(map(lambda key: col != key, list(item.keys()))),columnNames)), contentList)): # Check, if all dictionaries in the content list contain the keys, defined in columnNames
                    raise AttributeError('At least one dictionary misses at least one key, defined in the first attribute of table()!')
                self._table = list(map(lambda item: list(map(lambda key: item[key], columnNames)), contentList)) # Convert list of uniform dictionaries to list of uniform lists
            elif all(map(lambda x: isinstance(x, list), contentList)): # Process list of lists
                self._table = contentList
            else: # Something is very wrong, if we get here
                raise AttributeError('The second attribute, if not None, has to be a list of ONLY lists or a list of ONLY dictionaries!')
        else:
            self._table = []
        
    # Representation of table object
    def __repr__(self):
        return 'Table object with ' + str(len(self._table)) + ' entries.'
    
    # Printed output of table object
    def __str__(self):
        output=['\033[1m' + str(self._head) + '\033[0m']
        for i in self._table:
            output.append(str(i))
        return '\n'.join(output)
    
    # Magic method for "object['columnName']" accessor. Returns list of named columns content.
    def __getitem__(self, col):
        if col in self._head:
            i = self._head.index(col)
            output = []
            for j in self._table:
                output.append(j[i])
            return output
        else:
            raise AttributeError('table has no column named "' + str(col) + '"')
    
    # Magic method for len()-function, returns number of "rows"
    def __len__(self):
        return len(self._table)
    
    # Magic method to initialize iterator.
    def __iter__(self):
        self._index = 0
        self._row = None
        return self
    
    # Magic method to increment iterator.
    def __next__(self):
        if self._index > len(self._table) - 1:
            del self._index
            del self._row
            raise StopIteration
        else:
            self._row = self._table[self._index]
            output = dict(list(zip(self._head, self._row)))
            self._index = self._index + 1
            return output
    
    # Method to add "row".
    def add(self, row):
        if not isinstance(row, dict):
            raise TypeError('table.add() expects a dictionary as argument')
        if len(row) < len(self._head):
            raise ValueError('The argument of add_row has to be a dictionary with the length of at least ' + str(len(self._head)))
        if any(map(lambda col: all(map(lambda key: col != key, list(row.keys()))),self._head)):
            raise AttributeError('The dictionary given to table.add() misses at least one key, defined in the first attribute of table()!')
        self._table.append(list(map(lambda key: row[key], self._head)))
    
    # Method to search for "row(s)" containing defined pattern, which can be a dict or a string.
    def query(self, pattern):
        if not isinstance(pattern, (dict, str)):
            raise TypeError('table.query() takes a dict or a string as argument!')
        elif isinstance(pattern, dict):
            result = self._table
            for item in pattern:
                if item in self._head:
                    itemIndex = self._head.index(item)
                    result = list(filter(lambda x: x[itemIndex] == pattern[item], result))
        elif isinstance(pattern, str):
            result = []
            for ind in range(0, len(self._head)):
                result += list(filter(lambda x: x[ind] == pattern, self._table))
        if len(result) == 0: # Generate empty table, if no results were found.
            return table(self._head, None)
        else:
            return table(self._head, result)

## Class to hold structured data after extraction from source files and added meta information
class sourcedata:
    ## Constructor
    def __init__(self, tableVar, dictAlias=dict()):
        if isinstance(tableVar, table):
            self.variables = tableVar
        else:
            raise TypeError('Sourcedata expects a table as argument!')
        if isinstance(dictAlias, dict):
            self.aliases = dictAlias
        else:
            raise TypeError('Sourcedata expects a dictionary as aliases!')
    
    ## Recursion to expand all aliases in String
    def _expand(inStr):
        if isinstance(inStr,str):
            posOpen = inStr.find("{")
            if posOpen != -1:
                posClose = inStr.find("}",posOpen+1)
                if posClose == -1:
                    return inStr
            else:
                return inStr
            try:
                if posClose-posOpen > 1: # Check for empty curly brackets
                    macro = self.aliases[inStr[posOpen+1:posClose]]
                else:
                    sys.stderr.write(asciiformat.warning
                                     +'Empty alias in '
                                     +asciiformat.bold(inStr)
                                     +' will be ignored!\n')
                    macro = ''
            except KeyError:
                sys.stderr.write(asciiformat.error
                                 +'Alias '
                                 +asciiformat.bold(inStr[posOpen+1:posClose])
                                 +' is not defined! It will be ignored!\n')
                macro = ''
            out = self._expand(inStr[:posOpen] + macro + inStr[posClose+1:])
        return out
    
    ## Magic method for []-accessor 
    def __getitem__(self, match):
        if isinstance(match,str):
            query = self._expand(match)
            
        
def expandAlias(inString, aliasDict):
    '''
    Function to expand aliases
    '''
    posOpen = inString.find("{")
    if posOpen != -1:
        posClose = inString.find("}",posOpen+1)
        if posClose == -1:
            return inString
    else:
        return inString
    macro = aliasDict[inString[posOpen+1:posClose]]
    temp = inString[:posOpen] + macro + inString[posClose+1:]
    out = expandAlias(temp, aliasDict)
    return out    

def makeIndex(xmlNode, nsPrefix, nsDict, pvPath = ''):
    '''
    Recursive function to iterate through the xml tree and isolate the 'variables' while maintaining the path in order to generate an index.
    Takes:
        xmlNode: xml handle to start the recursion
        nsPrefix: Namespace prefix (without ':')
        nsDict: Namespace dictionary, containing nsPrefix
        pvPath: Path to the node, from which the function is called.
    Returns:
        index: dictionary, holding xpath and handle for the corresponding 'variable'-node
    '''
    index = {}
    for v in xmlNode.findall(nsPrefix + ':variable', nsDict):
        index[pvPath + v.get('name')] = v
    for d in xmlNode.findall(nsPrefix + ':directory', nsDict):
        index.update(makeIndex(d, nsPrefix, nsDict, pvPath = pvPath + d.get('name') + '/'))
    return index

def processXmlVariable(sourceHandle):
    '''
    Processes source file, defined in 'sourcefile' tag, with type 'xml-variables'.
    Returns table holding the content of sourcefile.
    '''
    if sourceHandle.get("type") != "xml-variables":
        raise XmlNodeError(sourceHandle.tag, 'sourcefile is not defined as type = xml-variables.')
    # Dictionary to convert c types into EPICS counterparts
    typeConversion = {'int32':'LONG',
                      'uint32':'ULONG',
                      'int16':'SHORT',
                      'uint16':'USHORT',
                      'int8':'CHAR',
                      'uint8':'UCHAR',
                      'double':'DOUBLE',
                      'float':'FLOAT',
                      'string':'STRING'}
    # Dictionary to convert "direction" to EPICS IN/OUT
    direction = {'control_system_to_application':'OUTPUT',
                 'control_system_to_application_with_return':'OUTPUT',
                 'application_to_control_system':'INPUT',
                 'application_to_control_system_with_return':'INPUT'}
    # Initialize output table
    out = table(['VariablePath', 'ValueType', 'NumberOfElements', 'Direction', 'Unit', 'Description'])
    # Getting xml parsing essentials
    label = sourceHandle.get("label")
    tree = ET.parse(sourceHandle.get("path"))
    root = tree.getroot()
    namespace = {label:sourceHandle.get("namespace")}
    # Indexing "variables" in xml file
    index = makeIndex(root, label, namespace)
    # Extract Information from source xml
    for variable in index.items():
        # Error Management
        try:
            vType = typeConversion[variable[1].find(label+':value_type', namespace).text]
        except KeyError:
            sys.stderr.write(asciiformat.warning
                             +asciiformat.bold(variable[1].find(label+':value_type', namespace).text)
                             +' is not a recognized variable type.\n')
            vType = None
        except AttributeError:
            sys.stderr.write(asciiformat.warning
                             +'Variable '
                             +asciiformat.bold(variable[0])
                             +' seems to have no <value_type> field.\n')
            vType = None        
        try:
            vDirection = direction[variable[1].find(label+':direction', namespace).text]
        except AttributeError:
            sys.stderr.write(asciiformat.warning
                             +'Variable '
                             +asciiformat.bold(variable[0])
                             +' seems to have no <direction> field.\n')
            vDirection = None
        try:
            vUnit = variable[1].find(label+':unit', namespace).text
        except AttributeError:
            sys.stderr.write(asciiformat.warning
                             +'Variable '
                             +asciiformat.bold(variable[0])
                             +' seems to have no <unit> field.\n')
            vUnit = ''
        out.add({
            'VariablePath':variable[0], 
            'ValueType':vType, 
            'Direction':vDirection,
            'Unit':vUnit,
            'Description':variable[1].find(label+':description', namespace).text,
            'NumberOfElements':int(variable[1].find(label+':numberOfElements', namespace).text)})
    return out

def findXDir(xmlRoot, nsPrefix, nsDict, xPath):
    '''
    Returns address of directory-node, described in xPath. 
    '''
    nodes = [xmlRoot]
    for node in xPath.split('/'):
        temp = nodes[-1].findall(nsPrefix + ":directory[@name='" + node + "']", nsDict)
        if len(temp) == 0:
            raise XmlNodeError(xPath, 'findXDir: "directory" node does not exist!')
        elif len(temp) > 1:
            sys.stderr.write(asciiformat.warning + 'Multiple directory-nodes named ' + node + ' found. First one will be used!\n')
        else:
            nodes.append(temp[0])
    return nodes[-1]

def getMacro(node, nsPrefix, nsDict):
    '''
    Returns a struct holding length and placeholder as defined in the FIRST "macro" tag under the xml.etree Element, given in "node"
    "nsDict" is a dict holding "nsPrefix" and namespace(s) as key:value pairs.
    '''
    nodeType = node.tag.split('}')[-1]
    if nodeType == 'outputfile':
        whatami = asciiformat.bold('outputfile') + ' for ' + asciiformat.bold(node.get('path'))
    elif nodeType == 'recordgroup':
        whatami = asciiformat.bold('recordgroup') + ' of type ' + asciiformat.bold(node.get('type'))
    elif nodeType == 'pv':
        whatami = asciiformat.bold('pv') + ' named ' + asciiformat.bold(node.get('pvName'))
    else:
        whatami = asciiformat.bold('unknown')
    output = struct()
    output.node = node.find(nsPrefix + ':macro', nsDict)
    if output.node == None:
        output.length = 0
        output.placeholder = ""
    else:
        tempLength = output.node.get('length')
        tempPH = output.node.get('placeholder')
        if tempLength == None:
            sys.stderr.write(asciiformat.warning + 'The macro defined under element ' + whatami + ' holds no ' + asciiformat.bold('length') + ' parameter! (Typo?)\nThere will be no place reseved for this macro! Could result in overlong PV names!\n')
            output.length = 0
        else:
            output.length = int(tempLength)
        if tempPH == None:
            sys.stderr.write(asciiformat.warning + 'The macro defined under element ' + whatami + ' holds no ' + asciiformat.bold('placeholder') + ' parameter! (Typo?)\nThere will no place be reseved for this macro! Could result in unexpected PV names!\n')
            output.length = 0
            output.placeholder = ""
        else:
            output.placeholder = str(output.node.get('placeholder'))
    return output

def getAutosave(node, nsPrefix, nsDict):
    '''
    Returns a boolean as defined in the FIRST "autosave" tag under the xml.etree Element, given in "node".
    "nsDict" is a dict holding "nsPrefix" and namespace(s) as key:value pairs.
    '''
    nodeType = node.tag.split('}')[-1]
    if nodeType == 'outputfile':
        whatami = asciiformat.bold('outputfile') + ' for ' + asciiformat.bold(node.get('path'))
    elif nodeType == 'recordgroup':
        whatami = asciiformat.bold('recordgroup') + ' of type ' + asciiformat.bold(node.get('type'))
    elif nodeType == 'pv':
        whatami = asciiformat.bold('pv') + ' named ' + asciiformat.bold(node.get('pvName'))
    else:
        whatami = asciiformat.bold('unknown')
    output = struct()
    output.node = node.find(nsPrefix + ':autosave', nsDict)
    if output.node == None:
        output.active = None
    elif output.node.get('isActive') == None:
        sys.stderr.write(asciiformat.warning + 'Autosave defined under element ' + whatami + ' holds no ' + asciiformat.bold('isActive') + ' parameter! (Typo?)\nAutosave will be ignored!\n')
        output.active = None
    elif output.node.get('isActive').lower() not in ['true', 'false']:
        sys.stderr.write(asciiformat.warning + 'Autosave defined under element ' + whatami + ' holds no ' + asciiformat.bold('isActive') + ' parameter! (Typo?)\nAutosave will be ignored!\n')
        output.active = None
    else:
        output.active = {'true':True, 'false':False}[output.node.get('isActive').lower()]
    return output.active

def getFields(node, nsPrefix, nsDict):
    '''
    Returns a dictionary holding all "field" tags type:value attributes under the xml.etree Element, given in "node" as key:value pairs.
    "nsDict" is a dict holding "nsPrefix" and namespace(s) as key:value pairs.
    '''
    nodeType = node.tag.split('}')[-1]
    if nodeType == 'outputfile':
        whatami = asciiformat.bold('outputfile') + ' for ' + asciiformat.bold(node.get('path'))
    elif nodeType == 'recordgroup':
        whatami = asciiformat.bold('recordgroup') + ' of type ' + asciiformat.bold(node.get('type'))
    elif nodeType == 'pv':
        whatami = asciiformat.bold('pv') + ' named ' + asciiformat.bold(node.get('pvName'))
    else:
        whatami = asciiformat.bold('unknown')
    output = dict()
    fieldNodes = node.findall(nsPrefix + ':field', nsDict)
    for field in fieldNodes:
        fieldType = field.get('type')
        fieldValue = field.get('value')
        if fieldType == None or fieldValue == None:
            sys.stderr.write(asciiformat.warning + 'Field defined under element ' + whatami + ' holds no ' + asciiformat.bold('type') + ' and/or ' + asciiformat.bold('value') + ' parameter! (Typo?)\nField will be ignored!\n')
        else:
            output[fieldType] = fieldValue # Fields of the same type overwrite!
    return output

CLAP=argparse.ArgumentParser(description='Generates EPICS PV database for every \'PV\' defined in ChimeraTK-xml file to EPICS database file.')
CLAP.add_argument('-c', help='Path to configuration file. Defaults to "mapConfig.xml"', metavar='path')
CLAP.add_argument('-v', help='Activates verbosity', action='store_true')
# Parse Command Line Arguments
CLA=CLAP.parse_args()

## Handle CLI arguments
# Handle default case
if CLA.c == None:
    inifilePath = os.getcwd()
    inifileName = 'mapConfig.xml'
else:
    inifilePath, inifileName = os.path.split(os.path.abspath(CLA.c))
    # Handle input of filename only
    if inifilePath == None:
        inifilePath = os.getcwd()
# Handle invalid/nonexisting paths
if not os.path.isdir(inifilePath):
    sys.exit(asciiformat.error + 'Path ' + inifilePath + ' does not exist.')
elif not os.path.isfile(os.path.join(inifilePath, inifileName)):
    sys.exit(asciiformat.error + 'File ' + inifileName + ' does not exist.')

## Parse config file os.path.join(inifilePath, inifileName)
if CLA.v:
    print("Reading: " + os.path.join(inifilePath, inifileName) + '\n')
cfgTree = ET.parse(os.path.join(inifilePath, inifileName))
cfgRoot = cfgTree.getroot()

# Define namespace
configNS={'EPICSmap' : 'https://github.com/ChimeraTK/ControlSystemAdapter-EPICS-IOC-Adapter'}
# Get a list of all sourcefile entries
sourcefiles = cfgRoot.findall("EPICSmap:sourcefile", configNS)

# Check existance of sourcefile element(s)
if len(sourcefiles) == 0:
    sys.stderr.write(asciiformat.warning + 'No source files are defined!\n')
else:
    if CLA.v:
        sourcelist=[]
        for i in sourcefiles:
            sourcelist.append(os.path.abspath(i.get("path")))
        print('Found ' + str(len(sourcefiles)) + ' sources:\n- ' + '\n- '.join(sourcelist) + '\n')
    source = dict()
    alias = dict()
    for sfile in sourcefiles:
        # Check if sourcefile exists
        if not os.path.isfile(sfile.get("path")):
            sys.stderr.write(asciiformat.warning + "File \'" + os.path.abspath(sfile.get("path")) + "\' does not exist!\n")
        # Parse source file according to type
        sourceTag = sfile.get("label")
        if sfile.get("type") == "xml-variables":
            source[sourceTag] = processXmlVariable(sfile)
            #parse aliases
            for item in sfile.findall('EPICSmap:alias', configNS):
                alias[sourceTag + '.' + item.get('varLabel')]=item.get('xmlPath')
        else:
            sys.stderr.write(asciiformat.warning + 'Source file type '+sfile.get("type")+' is unknown. Source file '+sfile.get("path")+' labeled '+sfile.get("label")+' will be ignored!\n')

# Get a list of all outputfile entries
outputFiles = cfgRoot.findall("EPICSmap:outputfile", configNS)
outputList=table(['type', 'path', 'handle'])
for i in outputFiles:
    outputFile = {'path' : os.path.abspath(i.get('path')), 'type' : i.get('type'), 'handle' : i}
    outputList.add(outputFile)
if CLA.v:
    print(str(len(outputList)) + ' output files are defined:\n' + str(outputList) + '\n')

for outFile in outputList:
    macro_rgroup = struct()
    macro_rgroup.length = 0
    macro_rgroup.placeholder = ""
    autosave_rgroup = None
    fields_rgroup = dict()
    if outFile['type'] == 'db':
        node=outFile['handle']
        # process attributes for the whole file
        macro_file = getMacro(node, 'EPICSmap', configNS)
        autosave_file = {None:False, False:False, True:True}[getAutosave(node, 'EPICSmap', configNS)]
        fields_file = getFields(node, 'EPICSmap', configNS)
        ## process recordgroups
        rgroupList = node.findall('EPICSmap' + ':recordgroup', configNS)
        for rgroupNode in rgroupList:
            macro_temp = getMacro(rgroupNode, 'EPICSmap', configNS)
            if macro_temp.node != None:
                macro_rgroup = macro_temp
            else:
                macro_rgroup = macro_file
            autosave_temp = getAutosave(rgroupNode, 'EPICSmap', configNS)
            if autosave_temp != None:
                autosave_rgroup = autosave_temp
            else:
                autosave_rgroup = autosave_file
            fields_rgroup = fields_file
            fields_rgroup.update(getFields(rgroupNode, 'EPICSmap', configNS))
            
        print(str(macro_rgroup.length) + '\t' + macro_rgroup.placeholder + '\n' + str(autosave_rgroup) + '\n' + str(fields_rgroup))